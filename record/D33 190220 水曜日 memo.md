[TOC]



# D33 190220 水曜日 memo

## 스택1

### 스택이란

* 소모성있는 문제를 풀지 말고 성장에 도움이 되는 문제를 풀자.

###### LIFO : 후입선출(Last-In-First-Out)

마지막에 삽입한 자료를 가장 먼저 꺼낸다.

"이번 시간에는 append, pop 메소드를 써도 된다."

스택에서 마지막 삽입된 원소의 위치를 top 이라 부른다.

top이란 용어는 전세계 관용적으로 통일.

스택의 묘미는 ''언제나'' top이 가리키는 공간을 뺀다.

**! top이 -1이면 스택이 비어있는 것이다.**

isSafe같은 함수도 스택을 이용한 것이다. 

* 연산

- 삽입: 저장소에 자료를 저장한다. 보통 push라고 부른다.
- 삭제: 저장소에서 자료를 꺼낸다. 보통 pop이라고 부른다.
- 스택이 공백인지 아닌지를 확인하는 연산.isEmpty
- 스택의 top에 있는 item(원소)을 반환하는 연산.peek

---

*1차원 배열을 사용*하여 구현할 경우 구현이 용이하다는 장점이 있지만 **스택의 크기를 변경하기가 어렵다**는 단점이 있다.

이를 해결하기 위한 방법으로 **저장소를 동적으로 할당하여 스택을 구현하는 방법**이 있다. 동적 연결리스트를 이용하여 구현하는 방법을 의미한다. 구현이 복잡하다는 단점이 있지만 **메모리를 효율적으로 사용한다는 장점**을 가진다. 스택의 동적 구현은 생략한다.

### 스택의 응용1 : 괄호검사

기출문제에 해당됨.

**괄호의 열고 닫는 순서는 스택을 이용한다.**

​	가장 먼저 열린 게 가장 나중에 닫히기 때문이다.

열린 괄호가 나올 때 스택에 push하고 닫힌 괄호가 나올 때 top에게 묻는다.

수식이 맞는지 확인 하는 법: 수식의 끝이 top=-1 이 나오는 것.

---

1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.
2. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
3. 괄호 사이에는 포함 관계만 존재한다.

* 괄호를 조사하는 알고리즘 개요

문자열에 있는 괄호를 차례대로 조사하면서 왼쪽 괄호를 만나면 스택에 삽입하고, 오른쪽 괄호를 만나면 스택에서 top괄호를 삭제한 후 오른쪽 괄호와 짝이 맞는지를 검사한다.

이 때, 스택이 비어 있으면 조건 1 또는 조건 2에 위배되고 괄호의 짝이 맞지 않으면 조건 3에 위배된다.

마지막 괄호까지를 조사한 후에도 스택에 괄호가 남아 있으면 조건 1에 위배된다.

"스택은 자료구조: 재료손질 중 하나이다. 알고리즘은 레시피다."

```python
import sys
sys.stdin = open('input.txt', 'r') # 파일에서 읽을 때 사용

stack=[0]*100
top = -1


Info = [0] * 128 #char 1byte ASCII code 7bit
Data = input()

Info[ord(')')] = '('
Info[ord(']')] = '['
Info[ord('>')] = '<'
Info[ord('}')] = '{'

howmany = len(Data)
for i in range(howmany):
    if Data[i] == '(' or Data[i] == '{' or Data[i] == '[' or Data[i] == '<':
        top += 1
        stack[top]= Data[i]
    elif Info[ord(Data[i])] == stack[top] :
        top -= 1
    else :
        top = 987654321
        break

if top==-1 : print("RIGHT")
else : print("WRONG")

```







### 재귀호출(RECURSION)

**자기 자신을 호출하여 순환 수행되는 것.**

함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성.

* base case : 기저에 있는 출력값. 이게 없으면 재귀함수가 무한 반복하는 함정에 빠질 수 있다.
* 재귀는 반드시 크기가 바뀌어야 끝이난다(=basecase가 존재한다).
* Return Address(R.A) : 내가 돌아갈 장소.(절대주소에 해당.)
  스택이 생기면 자동으로 생긴다.
* 함수가 리턴하는 방법은 2가지다.
  1. 자연사: 함수에 쓰여진 문장을 다 실행시킨다. ()
  2. 타살 : return을 작성하여 강제로 함수를 종료시킨다.

0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열을 피보나치라 한다.

피보나치 수열의 i번 째 값을 계산하는 함수 F를 정의하면 다음과 같다.

##### 점화식(볼링핀)

#### 피보나치 넘버

파도의 모양, 소라, 해바라기, 귓바퀴 등이 피보나치의 대표값.

#### 메모이제이션(memoization) 혹은 메모아이제이션

이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 함.

베이스케이스가 점점 높아지는 듯한 효과와 같음.(속도가 빨라짐).

#### DP(Dynamic Programming)



#### 하노이 타워

3줄로 코딩이 요약된다.

#### 계단오르기

확인해야할것. 1. 도착했는지. 2. 뛰어넘었는지.

#### DFS(Depth First Search)

1. 완전 탐색

2. 중복으로 거치지 않음.

##### Path, Cycle

방향 그래프. 

N by N 의 배열표를 만든다. 

* Indegree
* Outdegree



###### 과제

1. 괄호짝짓기

2. 계단오르기
3.  Ladder 재귀-
4.  Ladder 비재귀-



